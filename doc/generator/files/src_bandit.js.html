<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/bandit.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/BandIt.html">BandIt</a></li>
            
                <li><a href="../classes/BanditLogger.html">BanditLogger</a></li>
            
                <li><a href="../classes/pick.html">pick</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/BandIt.html">BandIt</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/bandit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The BandIt module provides methods to draw a workflow&lt;br/&gt;
 * Author: Olivier Sallou &lt;olivier.sallou@irisa.fr&gt;&lt;/br&gt;
 * License: CeCILL-B
 * @module BandIt
 * @requires RaphaelJS, JQuery
 *
 */

CONTAINER=1;


/**
 * BandIt is a library above RaphaelJS to create workflows in HTML/JS.
 * @class BandIt
 * @constructor
 * @param diveditor Name of the div where editor will be put
 * @param width Width of the div
 * @param height Height of the div
 */

function BandIt(diveditor,width,height) {
	// Raphael SVG
	this.paper = Raphael(diveditor,width,height);
	/**
	 * Operation mode:
	 * 0 : drag and drop, selection
	 * 1 : link
	 * 2 : delete
	 * 3 : group
	 */
	this.mode = 0;
	this.count = 0;
	this.currentnode = null;
	this.nodes = {};
	this.outlinks = {};
	this.inlinks = {};
	this.paths = {};
	this.zoom = 1;
	// Node properties object
	this.properties = {};
    this.options = {};

	this.selectCallbacks = [];
	this.deleteCallbacks = [];
	this.addCallbacks = [];
	
	this.name = &quot;bandit&quot;;
	this.description = &quot;&quot;;
	
	// selectgroup is assigned the rect node id of the selection
	this.selectgroup = 0;
	this.selectionx = -1;
	this.selectiony = -1;
	// contains the list of node ids selected
	this.selectnodes = [];
	
	// Record actions for undo/redo
	this.recordactions = true;
	this.action = -1;
	this.actions = [];
	this.maxactions = 100;
	
	mybandit = this;
	$(&#x27;#&#x27;+diveditor).mousedown(function(e) {
	    if(mybandit.mode!=3) {
	      return;
	    }
	    divposition = $(&#x27;#&#x27;+diveditor).position();
	    
	    var match=false;
	    mybandit.selectionx = e.pageX - divposition.left;
	    mybandit.selectiony = e.pageY -divposition.top;
	    mybandit.paper.forEach(function (el) {
	    if(mybandit.nodes[el.id]!=null) { // do not select text elements
	      var xselect = false;
	      var yselect = false;
	      if((mybandit.selectionx&gt;=el.attr(&quot;x&quot;))&amp;&amp;(mybandit.selectionx&lt;=(el.attr(&quot;x&quot;)+el.attr(&quot;width&quot;)))) {
	        xselect = true;
	      }
	      if((mybandit.selectiony&gt;=el.attr(&quot;y&quot;))&amp;&amp;(mybandit.selectiony&lt;=(el.attr(&quot;y&quot;)+el.attr(&quot;height&quot;)))) {
	        yselect = true;
	      }
	      
    	  if(xselect &amp;&amp; yselect) {
    	    match=true;
    	  }
    	  
    	}
    	});	    
		if(match==true) {
		  return;
		}

	      // Click on empty location
	      
	    if(mybandit.selectnodes.length&gt;0) {
	      // Reset group
	      mybandit.clearSelection();
	    }
	    else {
	      banditLogger.DEBUG(&#x27;start selection at &#x27;+(e.pageX - divposition.left)+&quot;:&quot;+(e.pageY -divposition.top));
	      mybandit.selectionx = e.pageX - divposition.left;
	      mybandit.selectiony = e.pageY -divposition.top;
	      mybandit.selectgroup = mybandit.paper.rect(mybandit.selectionx,mybandit.selectiony,1,1).id;
	    }
	    
     	
	});
	
	$(&#x27;#&#x27;+diveditor).mousemove(function(e) {
		if(mybandit.mode!=3) {
	      return;
	    }
	    
	    if(mybandit.selectgroup == 0) {
	      return;
	    }
	    divposition = $(&#x27;#&#x27;+diveditor).position();
		destx = e.pageX - divposition.left;
		desty = e.pageY -divposition.top;
	    selectrect = mybandit.paper.getById(mybandit.selectgroup);
	    if(destx&gt;mybandit.selectionx) {
	      posx = mybandit.selectionx;
	    }
	    else {
	      posx = destx;
	    }
	    if(desty&gt;mybandit.selectiony) {
	      posy = mybandit.selectiony;
	    }
	    else {
	      posy = desty;
	    }
	    selectrect.attr({ x: posx, y : posy, width: (Math.abs(destx - mybandit.selectionx))  , height: (Math.abs(desty - mybandit.selectiony)) });    	
	});
	
	
	$(&#x27;#&#x27;+diveditor).mouseup(function(e) {
		if(mybandit.mode!=3) {
	      return;
	    }
	    if(mybandit.selectgroup == 0) {
	      return;
	    }
	    
	    mybandit.paper.getById(mybandit.selectgroup).remove();
	    divposition = $(&#x27;#&#x27;+diveditor).position();
		destx = e.pageX - divposition.left;
		desty = e.pageY -divposition.top;
	    
	    mybandit.paper.forEach(function (el) {
	    if(mybandit.nodes[el.id]!=null) { // do not select text elements

	    var xselect = false;
	    var yselect = false;
	    if(destx&gt;mybandit.selectionx) { 
	      if((mybandit.selectionx &lt;= el.attr(&quot;x&quot;))&amp;&amp;(el.attr(&quot;x&quot;) &lt;= destx)) {
	        xselect = true;
	      }
	    }
	    else {
	      if((mybandit.selectionx &gt;= el.attr(&quot;x&quot;))&amp;&amp;(el.attr(&quot;x&quot;) &gt;= destx)) {
	        xselect = true;
	      }	    
	    }
	    if(desty&gt;mybandit.selectiony) { 
	      if((mybandit.selectiony &lt;= el.attr(&quot;y&quot;))&amp;&amp;(el.attr(&quot;y&quot;) &lt;= desty)) {
	        yselect = true;
	      }
	    }
	    else {
	      if((mybandit.selectiony &gt;= el.attr(&quot;y&quot;))&amp;&amp;(el.attr(&quot;y&quot;) &gt;= desty)) {
	        yselect = true;
	      }	    
	    }	    
    	  if(xselect &amp;&amp; yselect) {
    	    mybandit.selectnodes.push({ id : el.id, x: el.attr(&#x27;x&#x27;), y: el.attr(&#x27;y&#x27;) });
    	    mybandit.paper.getById(el.id).attr(&quot;opacity&quot;,0.6);
    	  }
    	} // end if not text
		});
	    mybandit.selectgroup = 0;
     	mybandit.selectionx = -1;
	    mybandit.selectiony = -1;
	});
}

/**
* Sets undo/redo buffer size
* @method setUndoRedo
* @param {int} Buffer size
*/
BandIt.prototype.setUndoRedo = function(max) {
  this.maxactions = max;
}


/**
* Clear group selection
* @method clearSelection
*/
BandIt.prototype.clearSelection = function() {
  // Reset group
  for(var i in this.selectnodes) {
    groupnode = mybandit.paper.getById(this.selectnodes[i][&quot;id&quot;]);
	if(groupnode!=null) {
	  if(mybandit.isContainer(this.selectnodes[i][&quot;id&quot;])) {
	    groupnode.attr(&quot;opacity&quot;,0.8);
	  }
	  else {
	    groupnode.attr(&quot;opacity&quot;,1);
	  }
	}
  }
  this.selectnodes = [];
}

/**
* Sets workflow name and description
* @method info
* @param name {String} Name of the workflow
* @param description {String} Description of the workflow
*
*/
BandIt.prototype.info = function(name,description) {
  banditLogger.DEBUG(&quot;Update info: &quot;+name+&quot;,&quot;+description);
  this.name = name;
  this.description = description;
}

/**
* Adds an arrow to a path
* @method arrow
* @param obj1 {Node} Start node
* @param obj2 {Node} End node
* @param connector {Path} Path object between nodes
* @return {Path} Arrow object
*
*/
BandIt.prototype.arrow = function(obj1, obj2, connector) {


  var bb1 = obj1.getBBox(),
        bb2 = obj2.getBBox(),
        p = [{x: bb1.x + bb1.width / 2, y: bb1.y - 1},
        {x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1},
        {x: bb1.x - 1, y: bb1.y + bb1.height / 2},
        {x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2},
        {x: bb2.x + bb2.width / 2, y: bb2.y - 1},
        {x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1},
        {x: bb2.x - 1, y: bb2.y + bb2.height / 2},
        {x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2}],
        d = {}, dis = [];
    for (var i = 0; i &lt; 4; i++) {
        for (var j = 4; j &lt; 8; j++) {
            var dx = Math.abs(p[i].x - p[j].x),
                dy = Math.abs(p[i].y - p[j].y);
            if ((i == j - 4) || (((i != 3 &amp;&amp; j != 6) || p[i].x &lt; p[j].x) &amp;&amp; ((i != 2 &amp;&amp; j != 7) || p[i].x &gt; p[j].x) &amp;&amp; ((i != 0 &amp;&amp; j != 5) || p[i].y &gt; p[j].y) &amp;&amp; ((i != 1 &amp;&amp; j != 4) 
|| p[i].y &lt; p[j].y))) {
                dis.push(dx + dy);
                d[dis[dis.length - 1]] = [i, j];
            }
        }
    }
    if (dis.length == 0) {
        var res = [0, 4];
    } else {
        res = d[Math.min.apply(Math, dis)];
    }
    var x1 = p[res[0]].x,
        y1 = p[res[0]].y,
        x4 = p[res[1]].x,
        y4 = p[res[1]].y;
    dx = Math.max(Math.abs(x1 - x4) / 2, 10);
    dy = Math.max(Math.abs(y1 - y4) / 2, 10);
    var x2 = [x1, x1, x1 - dx, x1 + dx][res[0]].toFixed(3),
        y2 = [y1 - dy, y1 + dy, y1, y1][res[0]].toFixed(3),
        x3 = [0, 0, 0, 0, x4, x4, x4 - dx, x4 + dx][res[1]].toFixed(3),
        y3 = [0, 0, 0, 0, y1 + dy, y1 - dy, y4, y4][res[1]].toFixed(3);

    var angle = Math.atan2(x1-x4.toFixed(3),y4.toFixed(3)-y1);
    angle = (angle / (2 * Math.PI)) * 360;

    var conn = connector.getBBox();
    var ax2 = conn.x+ conn.width/2;
    var ay2 = conn.y + conn.height/2;

    var size=10;


    var arrowPath = this.paper.path(&quot;M&quot; + ax2 + &quot; &quot; + ay2 + &quot; L&quot; + (ax2 - size) + &quot; &quot; + (ay2 - size) + &quot; L&quot; + (ax2 - size) + &quot; &quot; + (ay2 + size) + &quot; L&quot; + ax2 + &quot; &quot; + ay2 ).attr(&quot;fill&quot;,&quot;black&quot;).rotate((90+angle),ax2,ay2);


   return arrowPath;


}


/**
* Register a callback when a node is selected
* @method registerSelect
* @param callback Function to use when a node is selected, function(nodeid, nodeproperties)
*/
BandIt.prototype.registerSelect = function(callback) {
  this.selectCallbacks.push(callback);
}

/**
* Register a callback when a node is deleted
* @method registerDelete
* @param callback Function to use when a node is deleted, function(nodeid)
*/

BandIt.prototype.registerDelete = function(callback) {
  this.deleteCallbacks.push(callback);
}

/**
* Register a callback when a node is added
* @method registerAdd
* @param callback Function to use when a node is added, function(nodeid)
*/
BandIt.prototype.registerAdd = function(callback) {
  this.addCallbacks.push(callback);
}



/**
* Gets current edition mode
* @method getMode
* @return current {int}  mode
*
*/
BandIt.prototype.getMode = function() {
	return this.mode;
}

/**
* Sets current edition mode
* @method setMode
* @param newmode {int}  new edition mode
*
*/
BandIt.prototype.setMode = function(newmode) {
    if(this.mode==3 &amp;&amp; this.mode!=newmode) {
    // Special case, unselect any group
      if(this.selectnodes.length&gt;0) {
	    // Reset group
	    this.clearSelection();
	  }
    }
	this.mode = newmode;
    banditLogger.DEBUG(&quot;Switch to mode &quot;+this.mode);
}

/**
* Sets global workflow options
* @method setOptions
* @param options {Object} HashMap of options
*
*/
BandIt.prototype.setOptions = function(options) {
  this.options = options;
}

/**
* Get node properties
* @method getProperties
* @param nodeid {int} ID of the node
* @return {Object} Array of properties for the node
*/
BandIt.prototype.getProperties = function(nodeid) {
  if(this.nodes[nodeid]!=null) {
    return this.nodes[nodeid][&quot;properties&quot;];
  }
  else { return null; }
}

/**
* Get a node property
* @method getProperty
* @param nodeid {int} ID of the node
* @param key {String} Property key
* @return {String} Property value
*/
BandIt.prototype.getProperty = function(nodeid,key) {
  if(this.nodes[nodeid]!=null) {
    return this.nodes[nodeid][&quot;properties&quot;][key];
  }
  else { return null; }
}


/**
* Update the properties of a node
* @method setProperties
* @param nodeid {int} ID of the node
* @param props {Object} Properties of the node
*
*/

BandIt.prototype.setProperties = function(nodeid,props) {
    if(props[&quot;name&quot;]!=null &amp;&amp; this.nodes[nodeid][&quot;properties&quot;][&quot;name&quot;]!=null &amp;&amp; props[&quot;name&quot;]!=this.nodes[nodeid][&quot;properties&quot;][&quot;name&quot;]) {
        banditLogger.DEBUG(&quot;Change name of node &quot;+nodeid+&quot; to &quot;+props[&quot;name&quot;]);
      	oldtext = this.paper.getById(this.nodes[nodeid][&quot;child&quot;][&quot;text&quot;]);
      	oldtext.remove();
      	var node = this.paper.getById(nodeid);
      	xpos = node.attr(&quot;x&quot;) + node.attr(&quot;width&quot;)/2;
		ypos = node.attr(&quot;y&quot;) + node.attr(&quot;height&quot;)/2;
      	var nodetext = this.paper.text(xpos,ypos,props[&quot;name&quot;]).attr(&quot;fill&quot;,&quot;#FBFBEF&quot;);
		nodetext.attr(&quot;font-size&quot;,16*this.zoom);
		nodetext.toFront();
		this.nodes[node.id][&quot;child&quot;][&quot;text&quot;]=nodetext.id;
    }
	this.nodes[nodeid][&quot;properties&quot;] = props;
	this.newaction(&quot;setproperties&quot;);
}

BandIt.prototype.setAttributes = function(nodeid,attrs) {
    this.paper.getById(nodeid).attr(attrs);
    this.newaction(&quot;setattributes&quot;);
}

/**
* Sets default list of properties
* @method setDefaultProperties
* @param props {Object}  Key/value pairs of properties
*
*/

BandIt.prototype.setDefaultProperties = function(props) {
	this.properties = props;
}

/**
* get Rapahel Paper element
* @method getPaper
* @return {Paper} paper used for the draw
*/
BandIt.prototype.getPaper = function() {
  return this.paper;
}

/**
* Creates a directed link between two nodes
* @method link
* @param startnode {int} Id of start node
* @param endnode {int} Id of end node
* @return {int} Id of the graph link
*/
BandIt.prototype.link = function(startnodeid,endnodeid) {
  banditLogger.DEBUG(&quot;Link nodes &quot;+startnodeid+&quot; &lt;-&gt; &quot;+endnodeid);
  startnode = this.paper.getById(startnodeid);
  endnode = this.paper.getById(endnodeid);
  xpos = startnode.attr(&quot;x&quot;) + startnode.attr(&quot;width&quot;)/2;
  ypos = startnode.attr(&quot;y&quot;) + startnode.attr(&quot;height&quot;)/2;
  xend = endnode.attr(&quot;x&quot;) + endnode.attr(&quot;width&quot;)/2 ;
  yend = endnode.attr(&quot;y&quot;) + endnode.attr(&quot;height&quot;)/2 ;


  path = this.paper.path(this.getConnector(startnode,endnode));

  //path = this.paper.path(&quot;M&quot;+xpos+&quot;,&quot;+ypos+&quot;L&quot;+xend+&quot;,&quot;+yend);
  
  arrowpath = this.arrow(startnode,endnode,path);
  
  
  //banditLogger.DEBUG(&quot;add arrow &quot;+arrowpath.id);
  this.paths[path.id] =  { arrow : arrowpath.id, direction: endnode.id };
  mybandit = this;
  path.mousedown(function(e) {
    if(mybandit.mode==2) {
      path = mybandit.paper.getElementByPoint(e.x,e.y);
      mybandit.deletepath(path);
    }
  });
  path.toBack();
  
  if (this.inlinks[endnode.id] == null) {
    this.inlinks[endnode.id] = [];
  }
  this.inlinks[endnode.id].push({ path : path.id, node : startnode.id });
  if (this.outlinks[startnode.id] == null) { 
    this.outlinks[startnode.id] = [];
  }
  this.outlinks[startnode.id].push( { path : path.id, node : endnode.id });
  
  this.newaction(&quot;link&quot;);
  return path.id;
}


/**
* Gets a node id by its name
* @method getByName
* @param name {String} name of the node
* @return {int} Id of the node
*
*/
BandIt.prototype.getByName = function(name) {
  var nodeid = null;
  for(var node in this.nodes) {
    if(name == this.nodes[node][&quot;properties&quot;][&quot;name&quot;]) {
      nodeid = node;
      break;
    }
  }
  return nodeid;
}

/**
* Check if node is a container
* @method isContainer
* @param {integer} node id
* @return {boolean} True if it is a container, else returns false
*/
BandIt.prototype.isContainer = function(nodeid) {
  if(this.nodes[nodeid][&quot;type&quot;]!=null &amp;&amp; this.nodes[nodeid][&quot;type&quot;]==CONTAINER) {
    return true;
  }
  return false;
}

/**
* Adds a new node container on paper. A container acts as a node except it cannot be used
* for links, and nodes dropped in a container will be linked to the container (parent property of the node).
* @method addContainer
* @param name {string}  Unique name of the node (optional). If undefined, a default counter is used
* @param atts {Object}  Element properties (optional). For properties, look at Raphael Element documentation.
* @return {Node} Node element
*
*/
BandIt.prototype.addContainer = function(name,attrs) {
	var node = this.add(name,attrs);
	node.attr(&quot;width&quot;,200*this.zoom);
	node.attr(&quot;height&quot;,200*this.zoom);
	node.attr(&quot;opacity&quot;,0.8);
	node.attr(&quot;fill&quot;,&quot;#01DF01&quot;);
	node.toBack();
	this.nodes[node.id][&quot;type&quot;]=CONTAINER;
	this.action--; // Move back because has been registered as a node
	this.newaction(&quot;addcontainer&quot;);
    return node;
}

/**
* Adds a new node on paper
* @method add
* @param name {string}  Unique name of the node (optional). If undefined, a default counter is used
* @param atts {Object}  Element properties (optional). For properties, look at Raphael Element documentation.
* @return {Node} Node element
*
*/

BandIt.prototype.add = function(name,attrs) {
	var node = this.paper.rect(50,50, 100*this.zoom,60*this.zoom);
        nodeattr = pick(attrs,{ fill : &quot;#f00&quot; });
        node.attr(nodeattr);

	this.nodes[node.id] = {};
    this.nodes[node.id][&quot;properties&quot;] = {};
    for(var p in this.properties) {
	  this.nodes[node.id][&quot;properties&quot;][p] = this.properties[p];
    }

	xpos = node.attr(&quot;x&quot;) + node.attr(&quot;width&quot;)/2;
	ypos = node.attr(&quot;y&quot;) + node.attr(&quot;height&quot;)/2;

        nodename = pick(name, &quot;node&quot;+this.count);
        this.count += 1;

	var nodetext = this.paper.text(xpos,ypos,nodename).attr(&quot;fill&quot;,&quot;#FBFBEF&quot;);
	nodetext.attr(&quot;font-size&quot;,16*this.zoom);
	nodetext.toFront();
	this.nodes[node.id][&quot;child&quot;] = {}
	this.nodes[node.id][&quot;child&quot;][&quot;text&quot;]=nodetext.id;
	this.nodes[node.id][&quot;properties&quot;][&quot;name&quot;]=nodename;

	var mybandit = this;

	node.mousedown(function(e) {
			node = mybandit.paper.getElementByPoint(e.x,e.y);
			currentnode = node.id;
			if (mybandit.mode==1) {
			  // Link mode , nothing to do
			  return;
			}
			if (mybandit.mode==3) {
			  // Group mode , nothing to do
			  return;
			}
			if (mybandit.mode==2) {
			  // Delete mode, delete node
			  if(mybandit.selectnodes.length&gt;0) {
			    for(var i in selectnodes) {
			      mybandit.deletenode(selectnodes[i][&quot;id&quot;]);
			    }
			    mybandit.clearSelection();
			  }
			  else {
			    mybandit.deletenode(node.id);
			  }
			  return;
			}
			(&quot;node &quot;+node.id+&quot; selected&quot;);
                        // callbacks
                        for(var i in mybandit.selectCallbacks) {
                           mybandit.selectCallbacks[i](node.id,mybandit.nodes[node.id][&quot;properties&quot;]);
                        }
			});

	node.mouseup(function(e) {
			if (mybandit.mode==2) {
			return; 
			}
			if (mybandit.mode==3) {
			return; 
			}
			if (mybandit.mode==1) {
			  node = mybandit.paper.getElementByPoint(e.x,e.y);
			  if(node.id == currentnode) {
			    return; // Do not link same node
			  }
			  startnode = mybandit.paper.getById(currentnode);
			  if(!mybandit.isContainer(node.id)  &amp;&amp; !mybandit.isContainer(startnode.id)) {
			    mybandit.link(startnode.id, node.id);
			  }
			  else {
			    banditLogger.DEBUG(&quot;destination is container, drop link&quot;);
			  }
			}
	});

	var start = function () {
		if(mybandit.mode == 2) {
			return;
		}
		this.ox = this.attr(&quot;x&quot;);
		this.oy = this.attr(&quot;y&quot;);
		this.animate({ opacity: .25}, 500, &quot;&gt;&quot;); 
	};
	var move = function (dx, dy,x,y) {
		if(mybandit.mode == 1 || mybandit.mode==2) {
		}
		else {
		    var isselected = false;
		    for(var i in mybandit.selectnodes) {
		      if (mybandit.selectnodes[i][&quot;id&quot;]==this.id) {
		        isselected = true;
		        break;
		      }
		    }
			if(!isselected) {
			  deltax = (this.ox + dx) - this.attr(&quot;x&quot;);
			  deltay = (this.oy + dy) - this.attr(&quot;y&quot;);
			  this.attr({x: this.ox + dx, y: this.oy + dy});
			  xpos = this.ox + dx + this.attr(&quot;width&quot;)/2;
			  ypos = this.oy + dy + this.attr(&quot;height&quot;)/2;

			  mybandit.paper.getById(mybandit.nodes[this.id][&quot;child&quot;][&quot;text&quot;]).attr({x: xpos, y: ypos});
			  mybandit.redrawpaths(this.id);
			  // If container, move childs
			  if(mybandit.nodes[this.id][&quot;type&quot;]==CONTAINER) {
			    mybandit.moveChilds(this.id,deltax ,deltay);
			  }
			}
			else {
			 // move all elements
			 for(var i in mybandit.selectnodes) {
			    nodeposx=this.ox + dx;
			    nodeposy=this.oy + dy;
			    deltax = (this.ox + dx) - this.attr(&quot;x&quot;);
			    deltay = (this.oy + dy) - this.attr(&quot;y&quot;);
			    var node = mybandit.paper.getById(mybandit.selectnodes[i][&quot;id&quot;]);
			 	node.attr({x: mybandit.selectnodes[i][&quot;x&quot;] + dx, y: mybandit.selectnodes[i][&quot;y&quot;] + dy});
			    xpos = mybandit.selectnodes[i][&quot;x&quot;] + dx + node.attr(&quot;width&quot;)/2;
			    ypos = mybandit.selectnodes[i][&quot;y&quot;] + dy + node.attr(&quot;height&quot;)/2;
			    mybandit.paper.getById(mybandit.nodes[mybandit.selectnodes[i][&quot;id&quot;]][&quot;child&quot;][&quot;text&quot;]).attr({x: xpos, y: ypos});
			    mybandit.redrawpaths(mybandit.selectnodes[i][&quot;id&quot;]);
			    // If container, move childs
			    if(mybandit.selectnodes[i][&quot;type&quot;]==CONTAINER) {
			      mybandit.moveChilds(mybandit.selectnodes[i][&quot;id&quot;],deltax ,deltay );
			    }			 
			 }
			}
		}
	};
	var up = function () {
		if(mybandit.mode == 2 || mybandit.mode ==3) {
			return;
		}
		if(mybandit.isContainer(this.id)) {
		  this.animate({ opacity: 0.8}, 500, &quot;&gt;&quot;);
		}
		else {
		  this.animate({ opacity: 1}, 500, &quot;&gt;&quot;);
		}
		var nbox = mybandit.paper.getById(this.id).getBBox();
		var intersect = false;
		for(var container in mybandit.nodes) {
		  if(container != this.id &amp;&amp; mybandit.isContainer(container)) {
		    var cbox = mybandit.paper.getById(container).getBBox();
		    if(Raphael.isBBoxIntersect(nbox,cbox) &amp;&amp; (mybandit.nodes[container][&quot;parent&quot;]==null || mybandit.nodes[container][&quot;parent&quot;]!=this.id)) {
		      banditLogger.DEBUG(&quot;attach node to container &quot;+container);
		      mybandit.nodes[this.id][&quot;parent&quot;] = container;
		      mybandit.paper.getById(container).toBack();
		      intersect = true;
		    }
		  }
		  if(intersect) {
		    break;
		  }
		  else {
		   // Was in a container? remove it
		   if(mybandit.nodes[this.id][&quot;parent&quot;] != null) {
		     banditLogger.DEBUG(&quot;detach node from container &quot;+mybandit.nodes[this.id][&quot;parent&quot;]);
		     mybandit.nodes[this.id][&quot;parent&quot;] = null;
		   }
		  }
		}
		if(mybandit.mode != 1) {
	      // Do not record a move for a link
		  mybandit.newaction(&quot;move&quot;);
		}
	};

	node.drag(move,start,up);

       // callbacks
      for(var i in mybandit.addCallbacks) {
        mybandit.addCallbacks[i](node.id);
      }

    this.newaction(&quot;addnode&quot;);

	return node;

} // end add

/**
* Move childs of a container
* @method moveChidls
* @param {int} id of the container
* @param {int} X translation
* @param {int} Y translation
*/
BandIt.prototype.moveChilds = function(id,dx,dy) {

  for(var i in this.nodes) {
    if(this.nodes[i][&quot;parent&quot;] == id ) {
      //banditLogger.DEBUG(&quot;move child &quot;+i+&quot; - &quot;+dx+&quot;,&quot;+dy);
      var node = this.paper.getById(i);
      node.attr({x: node.attr(&quot;x&quot;)+ dx, y: node.attr(&quot;y&quot;) + dy});
	  xpos = this.nodes[i][&quot;x&quot;] + dx + node.attr(&quot;width&quot;)/2;
	  ypos = this.nodes[i][&quot;y&quot;] + dy + node.attr(&quot;height&quot;)/2;
	  var textnode = this.paper.getById(this.nodes[i][&quot;child&quot;][&quot;text&quot;]);
	  textnode.attr({x: textnode.attr(&quot;x&quot;)+ dx, y: textnode.attr(&quot;y&quot;) + dy});
	  //banditLogger.DEBUG(&quot;redraw links for &quot;+i);
	  if(this.nodes[i][&quot;type&quot;]==CONTAINER) {
	   // Recursive move
	   this.moveChilds(i,dx,dy);
	  }
	  this.redrawpaths(i);
	}
  }

}

// Redraw all path linked to current dragged node
/**
* Redraw all paths linked to a node
* @method redrawpaths
* @param nodeid {int}  Id of the Node
*
*/

BandIt.prototype.redrawpaths = function(nodeid) {
	node = this.paper.getById(nodeid);
	if (node == null ) {
		return;
	}
	if (this.outlinks[nodeid]!=null) {
		for(var i=0;i&lt;this.outlinks[nodeid].length;i++) {
			this.redrawpath(this.outlinks[nodeid][i], node);
		}
	}
	if (this.inlinks[nodeid]!=null) {
		for(var i=0;i&lt;this.inlinks[nodeid].length;i++) {
			this.redrawpath(this.inlinks[nodeid][i],node);
		}
	}
} // end redrawpaths

/**
* Delete a node
* @method deletenode
* @param nodeid {int} Node id to delete
*
*/

BandIt.prototype.deletenode = function(nodeid) {
    var node = this.paper.getById(nodeid);
	banditLogger.DEBUG(&quot;delete node &quot;+node.id);
        // callbacks
        for(var i in this.deleteCallbacks) {
          this.deleteCallbacks[i](node.id);
        }


    if(this.nodes[node.id][&quot;type&quot;] == CONTAINER) {
     // Delete childs of container
     for(var cnode in this.nodes) {
       if(this.nodes[cnode][&quot;parent&quot;] == node.id) {
         console.log(&quot;should delete &quot;+cnode);
         this.deletenode(cnode);
       }
     }
    
    }

	paths = this.outlinks[node.id];
	// Delete text
	if(this.nodes[node.id]!=null) {
	  text = this.paper.getById(this.nodes[node.id][&quot;child&quot;][&quot;text&quot;]);
	  if(text!=null) {
		text.remove();
	  }
	}

	// Remove paths linked to node, if any
	for(var i in paths) {
		if(paths[i]!=null) {
			var pathobject =  this.paper.getById(paths[i][&quot;path&quot;]);
			this.deletepath(pathobject);
		}
	}
	delete this.outlinks[node.id]; 

	paths = this.inlinks[node.id];
	for(var i in paths) {
		if(paths[i]!=null) {
			var pathobject =  this.paper.getById(paths[i][&quot;path&quot;]); 
			this.deletepath(pathobject);
		}
	}
	delete this.inlinks[node.id];

	delete this.nodes[node.id];
	node.remove();
	
	this.newaction(&quot;deletenode&quot;);

} // end deletenode

/**
* Delete a path
* @methode deletepath
* @param path {Path} Path element to delete
*
*/

BandIt.prototype.deletepath = function(path) {
	banditLogger.DEBUG(&quot;Delete link &quot;+path.id);
	pathid = path.id;
	for(var node in this.outlinks) {
		links = this.outlinks[node];
		for(var i in links) {
			if(links[i]!=null &amp;&amp; links[i][&quot;path&quot;]==pathid) {
				banditLogger.DEBUG(&quot;remove outlinks path &quot;+i);
				links[i]=null;
			}
		}
	}
	for(var node in this.inlinks) {
		links = this.inlinks[node];
		for(var i in links) {
			if(links[i]!=null &amp;&amp; links[i][&quot;path&quot;]==pathid) {
				banditLogger.DEBUG(&quot;remove inlinks path &quot;+i);
				links[i]=null;
			}
		}
	}
        arrow = this.paths[path.id][&quot;arrow&quot;];
        this.paper.getById(arrow).remove();
	path.remove();
	
	this.newaction(&quot;deletepath&quot;);

} // end deletepath

// Redraw a path element
/**
* Redraw a path
* @methode redrawpath
* @param link {Path} Path element to delete
* @param node {int} Id of the node the path is linked as origin
*
*/

BandIt.prototype.redrawpath = function(link,node) {
	if(link==null) {
		// A deleted path
		return;
	}
	path = this.paper.getById(link[&quot;path&quot;]);
    arrow = this.paths[path.id][&quot;arrow&quot;];
    this.paper.getById(arrow).remove();
	remotenode = this.paper.getById(link[&quot;node&quot;]);
	xend = remotenode.attr(&quot;x&quot;) + remotenode.attr(&quot;width&quot;)/2;
	yend = remotenode.attr(&quot;y&quot;) + remotenode.attr(&quot;height&quot;)/2;
	xpos = node.attr(&quot;x&quot;) + node.attr(&quot;width&quot;)/2;
	ypos = node.attr(&quot;y&quot;) + node.attr(&quot;height&quot;)/2;
	//path.attr(&quot;path&quot;,&quot;M&quot;+xpos+&quot;,&quot;+ypos+&quot;L&quot;+xend+&quot;,&quot;+yend);


	path.attr(&quot;path&quot;,this.getConnector(node,remotenode));

        arrowdirection = this.paths[path.id][&quot;direction&quot;];
	if(arrowdirection!=node.id) { 
          newarrow = this.arrow(node,remotenode,path);
        }
        else {
          newarrow = this.arrow(remotenode, node,path);
        }
        this.paths[path.id] = { arrow: newarrow.id, direction: arrowdirection } ;

} // end redrawpath


/**
* Get SVG path to connect two objects
* @methode getConnector
* @param obj1 {Node} Start node
* @param obj2 {Node} End node
*
*/
BandIt.prototype.getConnector  = function(obj1,obj2) {

  var bb1 = obj1.getBBox(),
        bb2 = obj2.getBBox(),
        p = [{x: bb1.x + bb1.width / 2, y: bb1.y - 1},
        {x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1},
        {x: bb1.x - 1, y: bb1.y + bb1.height / 2},
        {x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2},
        {x: bb2.x + bb2.width / 2, y: bb2.y - 1},
        {x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1},
        {x: bb2.x - 1, y: bb2.y + bb2.height / 2},
        {x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2}],
        d = {}, dis = [];
    for (var i = 0; i &lt; 4; i++) {
        for (var j = 4; j &lt; 8; j++) {
            var dx = Math.abs(p[i].x - p[j].x),
                dy = Math.abs(p[i].y - p[j].y);
            if ((i == j - 4) || (((i != 3 &amp;&amp; j != 6) || p[i].x &lt; p[j].x) &amp;&amp; ((i != 2 &amp;&amp; j != 7) || p[i].x &gt; p[j].x) &amp;&amp; ((i != 0 &amp;&amp; j != 5) || p[i].y &gt; p[j].y) &amp;&amp; ((i != 1 &amp;&amp; j != 4) 
|| p[i].y &lt; p[j].y))) {
                dis.push(dx + dy);
                d[dis[dis.length - 1]] = [i, j];
            }
        }
    }
    if (dis.length == 0) {
        var res = [0, 4];
    } else {
        res = d[Math.min.apply(Math, dis)];
    }
    var x1 = p[res[0]].x,
        y1 = p[res[0]].y,
        x4 = p[res[1]].x,
        y4 = p[res[1]].y;
    dx = Math.max(Math.abs(x1 - x4) / 2, 10);
    dy = Math.max(Math.abs(y1 - y4) / 2, 10);
    var x2 = [x1, x1, x1 - dx, x1 + dx][res[0]].toFixed(3),
        y2 = [y1 - dy, y1 + dy, y1, y1][res[0]].toFixed(3),
        x3 = [0, 0, 0, 0, x4, x4, x4 - dx, x4 + dx][res[1]].toFixed(3),
        y3 = [0, 0, 0, 0, y1 + dy, y1 - dy, y4, y4][res[1]].toFixed(3);

    return [&quot;M&quot;, x1.toFixed(3), y1.toFixed(3), &quot;C&quot;, x2, y2, x3, y3, x4.toFixed(3), y4.toFixed(3)].join(&quot;,&quot;);
}

/**
* Zoom in the workflow
* @methode zoomIn
*
*/

BandIt.prototype.zoomIn = function() {
	this.zoom = this.zoom * 2;
	banditLogger.DEBUG(&quot;zoom with &quot;+this.zoom);
	mybandit = this;
	mybandit.paper.forEach(function (el) {
			if(mybandit.nodes[el.id]!=null) {
			el.attr(&quot;x&quot;, el.attr(&quot;x&quot;) * 2);
			el.attr(&quot;y&quot;, el.attr(&quot;y&quot;) * 2);
			el.attr({ width : el.attr(&quot;width&quot;) * 2, height: el.attr(&quot;height&quot;) * 2 });
			xpos = el.attr(&quot;x&quot;) + el.attr(&quot;width&quot;)/2;
			ypos = el.attr(&quot;y&quot;) + el.attr(&quot;height&quot;)/2;
			text = mybandit.paper.getById(mybandit.nodes[el.id][&quot;child&quot;][&quot;text&quot;]);
			text.attr({x: xpos, y: ypos}).attr(&quot;font-size&quot;,text.attr(&quot;font-size&quot;) * 2);
			mybandit.redrawpaths(el.id);
			}
			});
	this.newaction(&quot;zoomin&quot;);
}

/**
* Zoom out the workflow
* @methode zoomOut
*
*/

BandIt.prototype.zoomOut = function() {
	this.zoom = this.zoom * 0.5;
	banditLogger.DEBUG(&quot;zoom with &quot;+this.zoom);
	mybandit = this;
	mybandit.paper.forEach(function (el) {
			if(mybandit.nodes[el.id]!=null) {
			el.attr({x: el.attr(&quot;x&quot;) * 0.5, y: el.attr(&quot;y&quot;) * 0.5});
			el.attr({ width : el.attr(&quot;width&quot;) * 0.5, height: el.attr(&quot;height&quot;) * 0.5});
			xpos = el.attr(&quot;x&quot;) + el.attr(&quot;width&quot;)/2;
			ypos = el.attr(&quot;y&quot;) + el.attr(&quot;height&quot;)/2;
			text = mybandit.paper.getById(mybandit.nodes[el.id][&quot;child&quot;][&quot;text&quot;]);
			text.attr({x: xpos, y: ypos}).attr(&quot;font-size&quot;,text.attr(&quot;font-size&quot;)*0.5);
			mybandit.redrawpaths(el.id);
			}
			});
	this.newaction(&quot;zoomout&quot;);
}

/**
* Translate on the left the workflow
* @methode moveLeft
* @param step {int} Step of the move
*
*/

BandIt.prototype.moveLeft = function(step) {
	mybandit = this;
	mybandit.paper.forEach(function (el) {
			if(mybandit.nodes[el.id]!=null) {
			el.attr({ x: el.attr(&quot;x&quot;) - step });
			xpos = el.attr(&quot;x&quot;) + el.attr(&quot;width&quot;)/2;
			ypos = el.attr(&quot;y&quot;) + el.attr(&quot;height&quot;)/2;
			mybandit.paper.getById(mybandit.nodes[el.id][&quot;child&quot;][&quot;text&quot;]).attr({x: xpos, y: ypos});
			mybandit.redrawpaths(el.id);
			}
			});
	this.newaction(&quot;move&quot;);
}

/**
* Translate on the right the workflow
* @methode moveRight
* @param step {int} Step of the move
*
*/
BandIt.prototype.moveRight = function(step) {
	mybandit = this;
	mybandit.paper.forEach(function (el) {
			if(mybandit.nodes[el.id]!=null) {
			el.attr({ x: el.attr(&quot;x&quot;) + step });
			xpos = el.attr(&quot;x&quot;) + el.attr(&quot;width&quot;)/2;
			ypos = el.attr(&quot;y&quot;) + el.attr(&quot;height&quot;)/2;
			mybandit.paper.getById(mybandit.nodes[el.id][&quot;child&quot;][&quot;text&quot;]).attr({x: xpos, y: ypos});
			mybandit.redrawpaths(el.id);
			}
			});
	this.newaction(&quot;move&quot;);
}

/**
* Translate to the up the workflow
* @methode moveUp
* @param step {int} Step of the move
*
*/
BandIt.prototype.moveUp = function(step) {
	mybandit = this;
	mybandit.paper.forEach(function (el) {
			if(mybandit.nodes[el.id]!=null) {
			el.attr({ y: el.attr(&quot;y&quot;) - step });
			xpos = el.attr(&quot;x&quot;) + el.attr(&quot;width&quot;)/2;
			ypos = el.attr(&quot;y&quot;) + el.attr(&quot;height&quot;)/2;
			mybandit.paper.getById(mybandit.nodes[el.id][&quot;child&quot;][&quot;text&quot;]).attr({x: xpos, y: ypos});
			mybandit.redrawpaths(el.id);
			}
			});
	this.newaction(&quot;move&quot;);
}

/**
* Translate to the down the workflow
* @methode moveDown
* @param step {int} Step of the move
*
*/
BandIt.prototype.moveDown = function(step) {
	mybandit = this;
	mybandit.paper.forEach(function (el) {
			if(mybandit.nodes[el.id]!=null) {
			el.attr({ y: el.attr(&quot;y&quot;) + step });
			xpos = el.attr(&quot;x&quot;) + el.attr(&quot;width&quot;)/2;
			ypos = el.attr(&quot;y&quot;) + el.attr(&quot;height&quot;)/2;
			mybandit.paper.getById(mybandit.nodes[el.id][&quot;child&quot;][&quot;text&quot;]).attr({x: xpos, y: ypos});
			mybandit.redrawpaths(el.id);
			}
			});
	this.newaction(&quot;move&quot;);
}

/**
* Resets the workflow
* @method clean
*
*/
BandIt.prototype.clean = function() {
	this.currentnode = null;
	this.nodes = {};
	this.outlinks = {};
	this.inlinks = {};
	this.paths = {};
	this.paper.clear();
	
	this.newaction(&quot;clean&quot;);
	
}

/**
* Imports a workflow, resetting undo/redo actions.
* @method import
* @param data {String} Workflow data
* @param clean {boolean} Clean exiting data or append to existing workflow
* @return {Array} Name and Description of the workflow
*/
BandIt.prototype.import = function(data,clean) {
  var res = this.load(data,clean);
  bandit.actions=[];
  bandit.action=-1;
  return res;
}


/**
* Loads a workflow
* @method load
* @param data {String} Workflow data
* @param clean {boolean} Clean exiting data or append to existing workflow
* @return {Array} Name and Description of the workflow
*/
BandIt.prototype.load = function (data,clean) {
  // If not clean, skip root
  data = data.replace(/(\n|\r)+$/, &#x27;&#x27;);
  wflow = JSON.parse($.base64.decode(data));
  var maxnodeid = 0;
  this.zoomFit();

  if(clean) {
	this.clean();
  }
  var wlinks = {}; // list of node id / node names to link with
  var wnodes = {}; // list of node name/node id pairs
  var wparents = {} // parent reference for containers
  this.name = wflow[&quot;workflow&quot;][&quot;name&quot;];
  this.description = wflow[&quot;workflow&quot;][&quot;description&quot;];
  for(var node in wflow[&quot;workflow&quot;]) {
    if(node==&quot;name&quot; || node==&quot;description&quot;) {
      continue;
    }
    var nexts = null;
    var newnode = null;
    if(!clean &amp;&amp; node==&quot;root&quot;) {
      // This is root and we are in append, so do not add/draw the root node
      var nexts = wflow[&quot;workflow&quot;][node][&quot;next&quot;];
      var nextnodes = nexts.split(&#x27;,&#x27;);
      // Get root node
      var rootnodeid = this.getByName(&quot;root&quot;);
      banditLogger.DEBUG(&quot;Root node id:&quot; +rootnodeid);
      wlinks[rootnodeid] = nextnodes; // register future links
      newnodeid = rootnodeid;
    }
    else {
      var newnode;
      if(wflow[&quot;workflow&quot;][node][&quot;type&quot;]!=null &amp;&amp; wflow[&quot;workflow&quot;][node][&quot;type&quot;]==CONTAINER) {
        newnode = this.addContainer(node,wflow[&quot;workflow&quot;][node][&quot;graph&quot;]);
      }
      else {
        newnode = this.add(node,wflow[&quot;workflow&quot;][node][&quot;graph&quot;]);
      }
      banditLogger.DEBUG(&quot;Load node: &quot;+node+&quot;,&quot;+newnode.id);
      if(node.indexOf(&quot;node&quot;)==0) {
        var patt=/node(\d+)/;
        var nodeid = patt.exec(node);
        if(nodeid.length&gt;0) {
         var newid = parseInt(nodeid[1]);
         if(newid&gt;maxnodeid) { maxnodeid = newid; }
        }
      }
      for(var prop in this.properties) {
        this.nodes[newnode.id][&quot;properties&quot;][prop]=wflow[&quot;workflow&quot;][node][prop];
      }
      // is node contained in container?
      if(wflow[&quot;workflow&quot;][node][&quot;parent&quot;]!=null) {
        wparents[newnode.id] = wflow[&quot;workflow&quot;][node][&quot;parent&quot;];
      }
      wnodes[node] = newnode.id;
      newnodeid = newnode.id;
    }
    var nexts = wflow[&quot;workflow&quot;][node][&quot;next&quot;];
    var nextnodes = nexts.split(&#x27;,&#x27;);
    if(nextnodes.length&gt;0 &amp;&amp; nextnodes[0]!=&quot;&quot;) {
      banditLogger.DEBUG(&quot;register link from &quot;+newnodeid+&quot; to &quot;+nextnodes);
      wlinks[newnodeid] = nextnodes; // register future links
    }
  } // end for wflow
  
  // Set parents
  for(var wparent in wparents) {
    banditLogger.DEBUG(&quot;Set parent of node &quot;+wparent);
    for(var containernode in this.nodes) {
      if(this.nodes[containernode][&quot;properties&quot;][&quot;name&quot;] == wparents[wparent]) {
        this.nodes[wparent][&quot;parent&quot;] = containernode;
        break;
      }
    }
  }
  
  // Add the links
  for(var wlink in wlinks) {
    banditLogger.DEBUG(&quot;Add links of node &quot;+wlink);
    for(var i in wlinks[wlink]) {
      remotenodeid = wnodes[wlinks[wlink][i]];
      originnodeid = wlink;
      this.link(originnodeid,remotenodeid); 
    }
  }
  
  this.count = maxnodeid + 1;
  

  
  return [this.name,this.workflow];
}

/**
* Zoom back to 1
* @method zoomFit
*
*/
BandIt.prototype.zoomFit = function() {
  if(this.zoom&gt;1) {
    this.zoomOut();
    this.zoomFit();
  }
  if(this.zoom&lt;1) {
    this.zoomIn();
    this.zoomFit();
  }
  
  this.newaction(&quot;zoomfit&quot;);
}

/**
* Export diagram to GraphML
* @method exportGraphML
* @return {String} GraphML workflow
*/
BandIt.prototype.exportGraphML = function() {
  var graph = &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;graphml xmlns=&quot;http://graphml.graphdrawing.org/xmlns&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://graphml.graphdrawing.org/xmlnshttp://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&quot;&gt;\n&#x27;;
  i = 0;
  // Define properties
  for(var key in this.properties) {
    graph += &#x27;&lt;key id=&quot;prop&#x27;+i+&#x27;&quot; for=&quot;node&quot; attr.name=&quot;&#x27;+key+&#x27;&quot; attr.type=&quot;string&quot;&gt;&lt;default&gt;&#x27;+this.properties[key]+&#x27;&lt;/default&gt;&lt;/key&gt;\n&#x27;;
    i += 1;
  }
  graph += &#x27;&lt;key id=&quot;type&quot; for=&quot;node&quot; attr.name=&quot;type&quot; attr.type=&quot;string&quot;&gt;&lt;default&gt;&lt;/default&gt;&lt;/key&gt;&#x27;;
  graph += &#x27;&lt;key id=&quot;parent&quot; for=&quot;node&quot; attr.name=&quot;parent&quot; attr.type=&quot;string&quot;&gt;&lt;default&gt;&lt;/default&gt;&lt;/key&gt;&#x27;;
  graph += &#x27;&lt;graph id=&quot;&#x27;+this.name+&#x27;&quot; edgedefault=&quot;directed&quot;&gt;\n&#x27;;
  graph += &#x27;&lt;desc&gt;&#x27;+this.description+&#x27;&lt;/desc&gt;&#x27;;
  // Now manage nodes
  for(var i in this.nodes)  {
    var node = this.nodes[i];
    graph += &#x27;&lt;node id=&quot;&#x27;+node[&quot;properties&quot;][&quot;name&quot;]+&#x27;&quot;&gt;&#x27;;
    //var attrs = this.paper.getById(i).attr();
    for(var prop in node[&quot;properties&quot;]) {
        graph += &#x27;&lt;data key=&quot;&#x27;+prop+&#x27;&quot;&gt;&#x27;+node[&quot;properties&quot;][prop]+&#x27;&lt;/data&gt;\n&#x27;;
    }
    if(node[&quot;type&quot;]==CONTAINER) {
      graph += &#x27;&lt;data key=&quot;type&quot;&gt;&#x27;+CONTAINER+&#x27;&lt;/data&gt;\n&#x27;;
    }
    if(node[&quot;parent&quot;]!=null) {
      graph += &#x27;&lt;data key=&quot;parent&quot;&gt;&#x27;+this.nodes[node[&quot;parent&quot;]][&quot;properties&quot;][&quot;name&quot;]+&#x27;&lt;/data&gt;\n&#x27;;
    }
    
    
    graph += &#x27;&lt;/node&gt;\n&#x27;;
    // Now manage links
    var nexts = this.outlinks[i];

    if(node[&quot;properties&quot;][&quot;name&quot;]!=&quot;root&quot;) {
      if(this.inlinks[i]==undefined &amp;&amp; node[&quot;type&quot;]!=CONTAINER) { alert(&quot;Warning, the node &quot;+node[&quot;properties&quot;][&quot;name&quot;]+&quot; is not linked to root node&quot;);}
    }
    var next = &quot;&quot;;
    var nbnext = 0;
    for (var j in nexts) {
      if(nexts[j]!=null) {
        next = this.nodes[nexts[j][&quot;node&quot;]][&quot;properties&quot;][&quot;name&quot;];
	graph += &#x27;&lt;edge id=&quot;&#x27;+i+&#x27;-&#x27;+j+&#x27;&quot; source=&quot;&#x27;+node[&quot;properties&quot;][&quot;name&quot;]+&#x27;&quot; target=&quot;&#x27;+next+&#x27;&quot;/&gt;\n&#x27;;
        nbnext += 1;
      }
    }
  }
  graph += &#x27;&lt;/graph&gt;\n&#x27;;
  graph += &#x27;&lt;/graphml&gt;&#x27;;
  return graph;
}

/**
* Export diagram to YAML format with all information
* @method export
* @return {String} YAML export of the workflow
*/
BandIt.prototype.export = function(silent) {
  var is_silent = pick(silent,false);
  var exportobject = {};
  exportobject[&quot;options&quot;] = {};
  for(var option in this.options) {
    exportobject[&quot;options&quot;][option] = this.options[option];
  }
  exportobject[&quot;workflow&quot;] = {};
  exportobject[&quot;workflow&quot;][&quot;name&quot;] = this.name;
  exportobject[&quot;workflow&quot;][&quot;description&quot;] = this.description;
  for(var i in this.nodes)  {
    var node = this.nodes[i];
    var attrs = this.paper.getById(i).attr();
    nodeprops = {};
    nodeprops[&quot;graph&quot;] = attrs;
    for(var prop in node[&quot;properties&quot;]) {
      if(prop!=&quot;name&quot;) {
        nodeprops[prop] = node[&quot;properties&quot;][prop];
      }
    }
    // Now manage links
    var nexts = this.outlinks[i];
    
    if(node[&quot;properties&quot;][&quot;name&quot;]!=&quot;root&quot;) {
      //banditLogger.DEBUG(this.inlinks[i]);
      if(this.inlinks[i]==undefined &amp;&amp; node[&quot;type&quot;]!=CONTAINER &amp;&amp; !is_silent) { alert(&quot;Warning, the node &quot;+node[&quot;properties&quot;][&quot;name&quot;]+&quot; is not linked to root node&quot;);}
    }
     
    var next = &quot;&quot;;
    var nbnext = 0;
    for (var j in nexts) {
      if(nexts[j]!=null) {
        if(nbnext&gt;0) {
          next += &quot;,&quot;;
        }
        next += this.nodes[nexts[j][&quot;node&quot;]][&quot;properties&quot;][&quot;name&quot;]; 
        nbnext += 1;
      }
    }
    if(next!=&quot;&quot;) {
      nodeprops[&quot;next&quot;] = next;
    }
    
    if(node[&quot;type&quot;]==CONTAINER) {
      nodeprops[&quot;type&quot;] = CONTAINER;
    }
    
    if(node[&quot;parent&quot;]!=null) {
      nodeprops[&quot;parent&quot;] = this.nodes[node[&quot;parent&quot;]][&quot;properties&quot;][&quot;name&quot;];
    }

    exportobject[&quot;workflow&quot;][node[&quot;properties&quot;][&quot;name&quot;]] = nodeprops;
  }
  
  if(!is_silent) {
    banditLogger.DEBUG(JSON.stringify(exportobject));
  }
  
  return JSON.stringify(exportobject);

}

/**
* Record a new action for undo/redo.
* Not yet implemented: move, delete
* @method newaction
* @param type {string} Optional action type (for debug)
*/
BandIt.prototype.newaction = function (type) {
  if(this.actions.length&gt;this.maxactions) {
    this.actions.pop();
  }
  if(this.recordactions) {
    this.action++;
    banditLogger.DEBUG(&quot;Record new action: &quot;+type);
    this.actions[this.action]=$.base64.encode(this.export(true));
    if(this.actions.length&gt;this.action) {
      // empty array after this point
      this.actions[this.action+1]=null;
    }
  }
}

/**
* Undo
* @method undo last action
*/
BandIt.prototype.undo = function() {
 if(this.action&gt;0 &amp;&amp; this.actions[this.action-1]!=null) {
   this.action--;
   var undo_action = this.actions[this.action];
   banditLogger.DEBUG(&quot;undo &quot;+this.action);
   this.recordactions = false;
   this.load(undo_action,true);
   this.recordactions = true;
 }
}

/**
* Redo
* @method redo last action
*/
BandIt.prototype.redo = function() {
 if(this.action&lt;this.actions.length-1 &amp;&amp; this.actions[this.action+1]!=null) {
   this.action++;
   var redo_action = this.actions[this.action];
   banditLogger.DEBUG(&quot;redo &quot;+this.action);
   this.recordactions = false;
   this.load(redo_action,true);
   this.recordactions = true;
 }
}

/**
* Eval an argument.
* @class pick
* @param arg {Object} Value to test
* @param def {Object} Default value
* @return {Object} default is undefined
*
*/
function pick(arg, def) {
   return (typeof arg == &#x27;undefined&#x27; ? def : arg);
}

/**
* BanditLogger
* @class BanditLogger
* @constructor
* @param level {int} Level of log: 0:DEBUG, 1:INFO, 2: ERROR
*
*/
var level = 2; // Error

function BanditLogger(newlevel) {
  level = newlevel;
}

/**
* Log a debug level message
* @method DEBUG
* @param msg {String} message to log
*
*/
BanditLogger.prototype.DEBUG = function(msg) {
  if (level&lt;=0) {
    date = new Date
    console.log(&quot;#DEBUG &quot;+date.toString()+&quot;: &quot;+msg);
  }
}

/**
* Log an info level message
* @method INFO
* @param msg {String} message to log
*
*/

BanditLogger.prototype.INFO = function(msg) {
  if (level&lt;=1) {
    date = new Date
    console.log(&quot;#INFO &quot;+date.toString()+&quot;: &quot;+msg);
  }
}

/**
* Log an error level message
* @method ERROR
* @param msg {String} message to log
*
*/

BanditLogger.prototype.ERROR = function(msg) {
  if (level&lt;=2) {
    date = new Date
    console.log(&quot;#ERROR &quot;+date.toString()+&quot;: &quot;+msg);
  }
}

banditLogger = new BanditLogger(2);




    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
